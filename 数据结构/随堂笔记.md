# 随堂笔记

## 第一讲 基本概念

### 1.1 什么是数据结构

计算多项式

```c++
// 常规算法, f(x) = a0 + a1*x + ... + an*x^n
#include<cmath>
double f(int n, double a[], double x){
    int i;
    double p = a[0];
    for(i=1; i<=n; i++){
        p += (a[i] * pow(x, i));
    }
    return p;
}

// 优化算法, f(x) = a0 + x*(a1 + x*(a2 + ... x*(an)))
double f(int n, double a[], double x){
    int i;
    double p = a[n];
    for(i=n; i>0; i--){
        p = a[i-1] + p*x;
    }
    return p;
}
```

程序运行计时

```c++
#include <ctime>
#include <iostream>
using namespace std;

clock_t start, stop;
double duration;

int main() {
  start = clock();  // main 函数开始运行到 start 被赋值这个时刻一共走过的 ticks
  stop = clock();  // main 函数开始运行到 stop 被赋值这个时刻一共走过的 ticks
  duration = ((double)(stop - start)) / CLK_TCK;
  cout << duration;
  return 0;
}
```

### 1.2 什么是算法

算法：

* 有限的指令集

* 接受一些输入（可以不输入）

* 产生输出（必须）

* 在有限步骤之后终止

* 每一条指令必须

  a. 明确无歧义
  
  b. 计算机可处理
  
  c. 不依赖单独某一种特定的计算机语言

空间复杂度 S(n)

时间复杂度 T(n)

最坏情况复杂度 T<sub>worst</sub>(n)

平均复杂度<sub>Tavg</sub>(n)

> T(n) = O(f(n)) 表示存在常数 C>0, n0>0 使得当 n>=n0 时有 T(n) <= C·f(n)，是 T(n) 上界
>
> T(n) = Ω(g(n)) 表示存在常数 C>0, n0>0 使得当 n>=n0 时有 T(n) >= C·g(n)，是 T(n) 下界
>
> T(n) = Θ(h(n)) 表示同时有 T(n) = O(h(n)) 和 T(n) = Ω(h(n))

复杂度比较：

> 1 < log(n) < n < nlog(n) < n^2 < n^3 < 2^n < n!

Tricks:

* 若两段算法分别有复杂度 T1(n) = O(f1(n)) 和 T2(n) = O(f2(n))，则：
  
  * T1(n) + T2(n) = max(O(f1(n)), O(f2(n)))

  * T1(n) x T2(n) = O(f1(n) x f2(n))

* 若 T(n) 是关于 n 的 k 阶多项式，那么 T(n) = Θ(n^k)

* 一个 for 循环的时间复杂度等于循环次数乘以循环体代码的复杂度

* if-else 结构的复杂度取决于 if 的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大
